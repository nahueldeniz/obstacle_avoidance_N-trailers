% casadi test for nmpc for unicycle
% FJP

clear all
close all
clc

import casadi.*

Nc      = 15;
Ts      = 0.1;

Lh1     = 0.342;
L1      = 1.08;
Lh2     = 0;
L2      = 0.78;

vr      = 0.3; % (m/s)
wr      = 0; % (rad/s)
kx      = 7.15;
ky      = 7.15;
ktheta  = 33.5;

opti    = casadi.Opti();

Ns      = 3;
Nd      = 3;
Nt      = 2;
nq      = 4*Nt+3;
nu      = 2;
nr      = 3;
dU_lb   = [-6; -3];
dU_ub   = [6; 3];

qNc     = opti.variable(nq,Nc+1);
u       = opti.variable(nu,Nc);

qref    = opti.parameter(nr);
qinit   = opti.parameter(nq);
u_last  = opti.parameter(nu);
ObsS    = opti.parameter(3,Ns); % [x;y;r]
ObsD    = opti.parameter(5,Nd); % [x,y,r,delta x, delta y]' x Nd: with delta x and delta y, I can predict the future position by a linear extrapolation

W       = diag([0.1 1 1]);
R       = diag([0.01 0.05]);


J1 = [-Lh1 * cos(qNc(1)) / L1, sin(qNc(1))/L1; Lh1*sin(qNc(1)), cos(qNc(1))];
J2 = [-Lh2 * cos(qNc(2)) / L2, sin(qNc(2))/L2; Lh2*sin(qNc(2)), cos(qNc(2))];      

%Función objetivo
J = 0;
for k=1:Nc+1
    J = J + (qNc([Nt+1,2*Nt+2:2*Nt+3],k)-qref).'* W *(qNc([Nt+1,2*Nt+2:2*Nt+3],k)-qref);
    if k < Nc+1
        opti.subject_to(qNc(:,k+1) == F(qNc(:,k),u(:,k),Nt,Ts,Lh1,L1,Lh2,L2));
        if k==1
            opti.subject_to( Ts.*dU_lb <= u(:,k)-u_last <= Ts.*dU_ub );
        else
            opti.subject_to( Ts.*dU_lb <= u(:,k)-u(:,k-1) <= Ts.*dU_ub );
        end        
        %
        J = J + u(:,k).'* R *u(:,k);
    end
    % handle static obstacles
    for j=1:Ns
        for i=1:Nt+1
            opti.subject_to( ObsS(3,j)^2 < (qNc(2*Nt+1+(i-1)*2+1,k)-ObsS(1,j))^2 + (qNc(2*Nt+1+i*2,k)-ObsS(2,j))^2);
%             J = J + 10*exp(-(1/(1e-3+ObsS(3,j)))*((qNc(2*Nt+1+(i-1)*2+1,k)-ObsS(1,j))^2 + (qNc(2*Nt+1+i*2,k)-ObsS(2,j))^2));
        end
    end
    % handle dynamis obstacles
    for j=1:Ns
        for i=1:Nt+1
            opti.subject_to( ObsD(3,j)^2 < (qNc(2*Nt+1+(i-1)*2+1,k)-(ObsD(1,j)+ObsD(4,j)*(k-1)*))^2 + (qNc(2*Nt+1+i*2,k)-ObsD(2,j))^2);
%             J = J + 10*exp(-(1/(1e-3+ObsD(3,j)))*((qNc(2*Nt+1+(i-1)*2+1,k)-ObsD(1,j))^2 + (qNc(2*Nt+1+i*2,k)-ObsD(2,j))^2));
        end
    end
end

opti.minimize(J);

opti.subject_to(-1 < u(2,:) < 1);                   %restriccion velocidad lineal
opti.subject_to(-45*pi/180 < u(1,:) < 45*pi/180);   %restriccion velocidad angular
opti.subject_to(qNc(:,1) == qinit);
%opti.subject_to(q(:,end)==qgoal);
%Definir solver

p_opts = struct('expand',true);
s_opts = struct('sb','yes','print_level',0,'gamma_theta',1e-2,'jacobian_approximation','exact','fast_step_computation','yes','warm_start_init_point','yes'); % 


opti.solver('ipopt',p_opts,s_opts);

%Setear parámetros
t           = 0:0.01:2*pi;
xref        = 10*cos(t);
yref        = 5.*sin(t);
thetaref    = unwrap(atan2(diff(yref),diff(xref)));
qr          = [[thetaref,thetaref(end)]; xref; yref];

opti.set_value(u_last,[0;0]);
%
opti.set_value(ObsS,zeros(3,Ns)); 
opti.set_value(ObsS(:,1),[0;5;0.5]); 
opti.set_value(ObsS(:,2),[-10;0;0.5]); 
opti.set_value(ObsS(:,3),[-5;-4;0.5]); 
%
opti.set_value(ObsD,zeros(3,Ns)); 
% opti.set_value(ObsD(:,1),[-5;4;0.5]); 
% opti.set_value(ObsD(:,2),[5;-4;0.5]); 
% opti.set_value(ObsD(:,3),[8.5;-2;0.5]); 

q0          = gen_x0(Nt,[0;0;pi/2],qr(2:3,1),Lh1,L1,Lh2,L2);
Q           = zeros(nq,length(t));
Q(:,1)      = q0;
Qr          = zeros(3,length(t));
Qe          = zeros(3,length(t));
u_mpc       = zeros(nu,length(t));
u_kc        = zeros(nu,length(t));
opti.set_value(u_last,[0;0]);
times       = zeros(1,length(t));

unfeasFlg = false;

for i=1:length(qr)-1
    tic;
    opti.set_value(qref,qr(:,i));
    opti.set_value(qinit,Q(:,i)); 
    % Static obstacles
%     opti.set_value(ObsS,Q(:,i)); 
    %
    try
        solve   = opti.solve();
    catch
        
    end
%     lam_g0 = solve.value(opti.lam_g);
    opti.set_initial(solve.value_variables());
    % Kinematic Controller (use reference generated by the MPC)
    Qtraj   = solve.value(qNc);
    Qr(:,i) = Qtraj([Nt+1,2*Nt+2:2*Nt+3],2);    % theta0, x0, y0
    theta   = Q(Nt+1,i);
    Qe(:,i) = [1 0 0; 0 cos(theta) sin(theta); 0 -sin(theta) cos(theta)] * (Qr(:,i)-Q([Nt+1,2*Nt+2:2*Nt+3],i));
    e1      = Qe(2,i);
    e2      = Qe(3,i);
    e3      = Qe(1,i);
    u_kc(:,i) = [wr + ky*vr*e2+ktheta*vr*sin(e3); vr*cos(e3)+kx*e1];
    % Velocities computed by the MPC
    Utraj   = solve.value(u);
    u_mpc(:,i) = Utraj(:,1);
    opti.set_value(u_last,u_mpc(:,i));
    % Evolve systemt
    Q(:,i+1) = F(Q(:,i),u_mpc(:,i),Nt,Ts,Lh1,L1,Lh2,L2);
    %
    times(i) = toc;
end


figure; hold on; grid on;
plot(qr(2,:),qr(3,:))
plot(Q(2*Nt+2,:),Q(2*Nt+3,:),'y',Q(2*Nt+4,:),Q(2*Nt+5,:),'b',Q(2*Nt+6,:),Q(2*Nt+7,:),'r')
daspect([1 1 1])

figure; hold on; grid on;
plot(u_mpc(1,:),'g'); plot(u_mpc(2,:),'b')
plot(u_kc(1,:),'g-.'); plot(u_kc(2,:),'b-.')






function Fk = F(q,u,Nt,Ts,Lh1,L1,Lh2,L2)
    J1 = [-Lh1 * cos(q(1)) / L1, sin(q(1))/L1; Lh1*sin(q(1)), cos(q(1))];
    J2 = [-Lh2 * cos(q(2)) / L2, sin(q(2))/L2; Lh2*sin(q(2)), cos(q(2))];      
    
    f_rhs  = [  [1 0] * (eye(2)-J1) * u;
                [1 0] * (eye(2)-J2) * J1 * u;
                %
                [1 0] * u;
                [1 0] * J1 * u;
                [1 0] * J2 * J1 * u;
                %
                [0 cos(q(Nt+1))] * u;
                [0 sin(q(Nt+1))] * u;
                [0 cos(q(Nt+2))] * J1 * u;
                [0 sin(q(Nt+2))] * J1 * u;
                [0 cos(q(Nt+3))] * J2 * J1 * u;
                [0 sin(q(Nt+3))] * J2 * J1 * u];
    
    
    Fk = q + Ts.*f_rhs;
end

function x0 = gen_x0(Nt,x_y_theta,x_y_ref,Lh1,L1,Lh2,L2)
    % DO NOT FORGET CHECKING FEASIBILITY OF INITIAL CONDITION!!!
    if nargin == 1
        Dx          = x_y_ref(1,2)-x_y_ref(1,1);
        Dy          = x_y_ref(2,2)-x_y_ref(2,1);
        theta0      = atan2(Dy,Dx);
        thetas      = repmat(theta0,Nt+1,1);
        xy_0        = x_y_ref(:,1);
    else        
        thetas      = [x_y_theta(3:end)'; repmat(x_y_theta(end),Nt+1-length(x_y_theta(3:end)),1)];
        xy_0        = x_y_theta(1:2);%[xAux;yAux];
    end
    betas   = -diff(thetas);    
    %
    xy_1    = xy_0 - [Lh1*cos(thetas(1))+L1*cos(thetas(2)); Lh1*sin(thetas(1))+L1*sin(thetas(2))];
    xy_N    = xy_1 - [Lh2*cos(thetas(2))+L2*cos(thetas(3)); Lh2*sin(thetas(2))+L2*sin(thetas(3))];
    xy_0toN = [xy_0;xy_1;xy_N];
    x0      = [ betas; thetas; xy_0toN];
end
